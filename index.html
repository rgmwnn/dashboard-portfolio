<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Supergoop! Customer Review Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-color: #f8bbd0;
            --accent-color: #e91e63;
            --text-color: #333;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #757575;
            --white: #ffffff;
            --shadow: 0 2px 10px rgba(0,0,0,0.05);
            --border-radius: 8px;
            --transition: all 0.3s ease;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--light-gray);
            color: var(--text-color);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--medium-gray);
        }
        
        h1 {
            font-family: 'Montserrat', sans-serif;
            font-size: 28px;
            font-weight: 600;
            color: var(--text-color);
        }
        
        .last-updated {
            font-family: 'Montserrat', sans-serif;
            font-size: 14px;
            color: var(--dark-gray);
        }
        
        .filters {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .filter-group {
            flex: 1;
            min-width: 200px;
        }
        
        label {
            font-family: 'Montserrat', sans-serif;
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
            color: var(--dark-gray);
        }
        
        select {
            font-family: 'Montserrat', sans-serif;
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--medium-gray);
            border-radius: var(--border-radius);
            background-color: var(--white);
            font-size: 14px;
            transition: var(--transition);
        }
        
        select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(233, 30, 99, 0.2);
        }
        
        .kpi-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .kpi-card {
            background-color: var(--white);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            text-align: center;
        }
        
        .kpi-value {
            font-family: 'Montserrat', sans-serif;
            font-size: 32px;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--accent-color);
        }
        
        .kpi-label {
            font-family: 'Montserrat', sans-serif;
            font-size: 14px;
            color: var(--dark-gray);
        }
        
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background-color: var(--white);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        
        .chart-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        
        .chart-container {
            position: relative;
            height: 250px;
        }
        
        .keywords-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .loading {
            font-family: 'Montserrat', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: var(--dark-gray);
        }
        
        .no-data {
            font-family: 'Montserrat', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            color: var(--dark-gray);
            font-style: italic;
        }
        
        .benchmark-container {
            background-color: var(--white);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 30px;
        }
        
        .benchmark-chart {
            position: relative;
            height: 200px;
        }
        
        .products-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .product-list {
            background-color: var(--white);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }
        
        .product-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--light-gray);
        }
        
        .product-item:last-child {
            border-bottom: none;
        }
        
        .product-name {
            font-family: 'Montserrat', sans-serif;
            font-weight: 500;
            color: var(--text-color);
        }
        
        .product-rating {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .rating-stars {
            color: #ffc107;
        }
        
        .rating-value {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
            color: var(--text-color);
        }
        
        .rating-count {
            font-family: 'Montserrat', sans-serif;
            font-size: 12px;
            color: var(--dark-gray);
        }
        
        .problems-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .problem-card {
            background-color: var(--white);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: var(--transition);
            position: relative;
        }
        
        .problem-card:hover {
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }
        
        .problem-card.active {
            border: 2px solid var(--accent-color);
        }
        
        .problem-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        
        .problem-value {
            font-family: 'Montserrat', sans-serif;
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-color);
        }
        
        .problem-description {
            font-family: 'Montserrat', sans-serif;
            font-size: 14px;
            color: var(--dark-gray);
            margin-top: 5px;
        }
        
        .recommendation-container {
            display: none;
            background-color: var(--white);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 30px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }
        
        .recommendation-container.show {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        .recommendation-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        
        .recommendation-goal {
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 15px;
            color: var(--text-color);
        }
        
        .recommendation-section {
            margin-bottom: 20px;
        }
        
        .recommendation-section-title {
            font-family: 'Montserrat', sans-serif;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color);
        }
        
        .recommendation-list {
            list-style-type: none;
            padding-left: 20px;
        }
        
        .recommendation-list li {
            font-family: 'Montserrat', sans-serif;
            font-size: 14px;
            margin-bottom: 8px;
            position: relative;
            padding-left: 15px;
            line-height: 1.5;
        }
        
        .recommendation-list li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: var(--accent-color);
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .charts-container {
                grid-template-columns: 1fr;
            }
            
            .keywords-container {
                grid-template-columns: 1fr;
            }
            
            .products-container {
                grid-template-columns: 1fr;
            }
            
            .problems-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1 id="dashboard-title">Loading Dashboard...</h1>
            <div class="last-updated" id="last-updated">Loading...</div>
        </header>
        
        <div class="filters">
            <div class="filter-group">
                <label for="brand-filter">Brand</label>
                <select id="brand-filter">
                    <option value="">Loading...</option>
                </select>
            </div>
            
            <div class="filter-group">
                <label for="category-filter">Secondary Category</label>
                <select id="category-filter">
                    <option value="">Loading...</option>
                </select>
            </div>
        </div>
        
        <div class="kpi-cards">
            <div class="kpi-card">
                <div class="kpi-value" id="weighted-rating">-</div>
                <div class="kpi-label">Weighted Rating</div>
            </div>
            
            <div class="kpi-card">
                <div class="kpi-value" id="pwrs-share">-</div>
                <div class="kpi-label">PWRS Share</div>
            </div>
            
            <div class="kpi-card">
                <div class="kpi-value" id="total-reviews">-</div>
                <div class="kpi-label">Total Reviews</div>
            </div>
            
            <div class="kpi-card">
                <div class="kpi-value" id="positive-share">-</div>
                <div class="kpi-label">Positive Share</div>
            </div>
            
            <div class="kpi-card">
                <div class="kpi-value" id="negative-share">-</div>
                <div class="kpi-label">Negative Share</div>
            </div>
        </div>
        
        <div class="products-container">
            <div class="product-list">
                <div class="chart-title">Top 5 Highest-Rated Products</div>
                <div id="highest-rated-products">
                    <div class="loading">Loading products...</div>
                </div>
            </div>
            
            <div class="product-list">
                <div class="chart-title">Top 5 Lowest-Rated Products</div>
                <div id="lowest-rated-products">
                    <div class="loading">Loading products...</div>
                </div>
            </div>
        </div>
        
        <div class="charts-container">
            <div class="chart-card">
                <div class="chart-title">Rating Breakdown</div>
                <div class="chart-container">
                    <canvas id="rating-chart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">Positive Drivers</div>
                <div class="chart-container">
                    <canvas id="positive-drivers-chart"></canvas>
                </div>
            </div>
            
            <div class="chart-card">
                <div class="chart-title">Negative Drivers</div>
                <div class="chart-container">
                    <canvas id="negative-drivers-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="chart-card">
            <div class="chart-title">Top Keywords</div>
            <div class="keywords-container">
                <div class="chart-container">
                    <canvas id="positive-keywords-chart"></canvas>
                </div>
                <div class="chart-container">
                    <canvas id="negative-keywords-chart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="benchmark-container" id="benchmark-container" style="display: none;">
            <div class="chart-title">Benchmark Comparison</div>
            <div class="benchmark-chart">
                <canvas id="benchmark-chart"></canvas>
            </div>
        </div>
        
        <div class="problems-container">
            <div class="problem-card" id="low-rating-problem" onclick="toggleRecommendation('low-rating')">
                <div class="problem-title">Low Rating</div>
                <div class="problem-value">3.87</div>
                <div class="problem-description">Current weighted rating is below target</div>
            </div>
            
            <div class="problem-card" id="low-pwrs-problem" onclick="toggleRecommendation('low-pwrs')">
                <div class="problem-title">Low Price-Weighted Review Share</div>
                <div class="problem-value">1.66%</div>
                <div class="problem-description">Current PWRS is below target</div>
            </div>
        </div>
        
        <div class="recommendation-container" id="recommendation-container">
            <!-- Content will be dynamically inserted here -->
        </div>
    </div>

    <script>
        // Global variables
        let dashboardData = null;
        let charts = {
            rating: null,
            positiveDrivers: null,
            negativeDrivers: null,
            positiveKeywords: null,
            negativeKeywords: null,
            benchmark: null
        };
        
        // Recommendation content data
        const recommendationData = {
            'low-rating': {
                title: 'Recommendation for Low Rating',
                goal: 'Goal: Move Weighted Rating toward ≥4.2 by eliminating the highest-frequency friction on the highest-weight SKUs (not by broad "brand messaging").',
                sections: [
                    {
                        title: 'Action plan (highly actionable)',
                        items: [
                            'Do a "Top-Impact SKU" strike list (Week 1): Pull the top-reviewed SKUs, then select the top 5 lowest-rated among them (your deck already frames this as highest ROI). For each SKU, assign one primary hotspot objective (e.g., "reduce greasy finish complaints").',
                            'Convert complaints into fix-specs (Week 1–2): For each priority SKU, turn negative keywords into "non-negotiable requirements": Greasy / heavy / sticky → target dry-down time, finish, slip, and transfer behavior; White cast → pigment dispersion / tint strategy / instructions per skin tone range; Pilling → compatibility with common moisturizers/primers + layer-order guidance; Breakouts / rash / irritation / eye sting → irritant audit + sensitive-skin guidance + "eye area" usage warnings',
                            'Ship "usage guidance fixes" immediately (Week 2) before formula changes: Update PDP + packaging instructions to reduce user-error-driven negatives: amount (2-finger rule), wait time before makeup, reapply cadence, water/sweat conditions, and "avoid direct eye line" guidance if eye-sting appears. This is the fastest lever while R&D works.',
                            'Add a "Compatibility Matrix" on PDP (Week 2–3): A small block: Best for: oily/dry/sensitive; Under makeup: yes/no; Finish: dewy/matte; White-cast risk: low/med/high; Reapply feel: light/med/heavy. This directly targets Sensory + Makeup Compatibility drivers.',
                            'Implement a "Complaint-rate QC gate" for new batches (Month 1–2): For the priority SKUs, track complaint rate per 1,000 reviews for: greasy, white cast, pilling, irritation/eye sting. Use it as a release gate for reformulation/packaging updates.',
                            'Run a "neutral-to-positive conversion" program (Month 1): Your deck maps 3★ as neutral; target these users with education: "how to apply," "how much product," "best pairing," "what finish to expect," "when it\'s worth upgrading to tinted." This protects 4–5★ share and reduces drift into 1–2★.',
                            'Proof upgrade (Month 1–2): Where performance/efficacy is questioned, add credible proof cues (usage conditions, clinical/stat claims where valid, clear reapply guidance). The goal is to strengthen "works/protects" confidence, which your positives already show.',
                            'Operational "fast fixes" (Week 2–4): If Packaging/Practical Issues show up (you have it as a driver), resolve leakage, cap durability, pump clogging, etc. These are fast wins that disproportionately reduce 1–2★ anger.'
                        ]
                    },
                    {
                        title: 'Success tracking (simple + defensible)',
                        items: [
                            'Primary: Weighted Rating ↑; 1–2★ share ↓, 4–5★ share stable/↑ (your deck\'s core KPI framing).',
                            'Driver KPIs: Complaint-rate per 1,000 reviews for greasy, white cast, pilling, irritation/eye sting ↓',
                            'SKU KPIs: Rating lift on the 5 priority SKUs + reduction in their "gap contribution" (review-weight × rating shortfall)'
                        ]
                    }
                ]
            },
            'low-pwrs': {
                title: 'Recommendation for Low PWRS',
                goal: 'Goal: Lift PWRS share toward ≥2.0% by increasing value-weighted attention (review volume × price) through hero SKU positioning, assortment/value framing, and conversion drivers—not just "more reviews."',
                sections: [
                    {
                        title: 'Action plan (highly actionable)',
                        items: [
                            'Identify "PWRS Leverage SKUs" (Week 1): Rank SKUs by (price × review volume) and pick: High price + medium reviews (big upside); High reviews + mid/high price (protect + amplify); Low PWRS contributors to deprioritize (long tail). This aligns with your "Pareto effect" framing: move the heavy hitters first.',
                            'Hero SKU repositioning (Week 2–4): On Sephora-facing assets (PDP, imagery, bullets), lead with the already-proven positives: effective/works well, absorbs quickly, gentle, tinted helps finish. These are your "conversion levers" tied to positive drivers.',
                            'Value framing to neutralize "too expensive" (Week 2): Don\'t discount first. Add crisp math + usage clarity: "cost per application" estimate; "how long it lasts" with correct amount guidance; highlight multi-benefit (SPF + primer-like finish, tinted coverage, etc.) where true. This is explicitly recommended in your deck (reduce value resistance without racing to discount).',
                            'Bundle strategy that increases PWRS numerator (Month 1): Launch bundles/discovery sets that anchor on higher-priced heroes (or higher-value kits), designed to convert trial → full-size. Bundles increase value-weighted attention while protecting brand premium.',
                            'Review generation focused on high-price/high-margin items (Month 1): Trigger review requests post-purchase specifically for PWRS leverage SKUs (email/SMS via retailer tools where possible). Objective: shift review volume toward higher price points, not evenly across SKUs.',
                            'Assortment cleanup (Month 1–2): If certain SKUs repeatedly underperform on rating (dragging conversion), reduce emphasis and redirect traffic to higher-performing variants (e.g., tinted/no-cast options) that align with positive drivers. This links PWRS growth to quality signals.',
                            'Close the benchmark gap with a two-move combo (Quarterly): Your benchmark shows leaders combine higher ratings + higher PWRS; therefore PWRS lift needs (a) rating lift on priority SKUs + (b) merchandising/assortment that pushes value-weighted mix. Treat it as one program, not two separate workstreams.'
                        ]
                    }
                ]
            }
        };
        
        // Formatters
        const percent = (x) => (x * 100).toFixed(1) + '%';
        const number = (x) => new Intl.NumberFormat().format(x);
        
        // Helper function to get slice data
        function getSlice(brandId, secondaryCategoryId) {
            if (!dashboardData || !dashboardData.cubes || !dashboardData.cubes.brand_secondary_category_slices) {
                return null;
            }
            
            const slices = dashboardData.cubes.brand_secondary_category_slices;
            
            // Try to find exact match
            let slice = slices.find(s => s.brand_id === brandId && s.secondary_category_id === secondaryCategoryId);
            
            // If not found, try to find "__ALL__" slice for the brand
            if (!slice && secondaryCategoryId !== "__ALL__") {
                slice = slices.find(s => s.brand_id === brandId && s.secondary_category_id === "__ALL__");
            }
            
            return slice || null;
        }
        
        // Toggle recommendation visibility
        function toggleRecommendation(problemType) {
            // Remove active class from all problem cards
            document.querySelectorAll('.problem-card').forEach(card => {
                card.classList.remove('active');
            });
            
            // Hide recommendation container
            const recommendationContainer = document.getElementById('recommendation-container');
            recommendationContainer.classList.remove('show');
            
            // Add active class to the clicked problem card
            const problemCardId = problemType + '-problem';
            const problemCardElement = document.getElementById(problemCardId);
            if (problemCardElement) {
                problemCardElement.classList.add('active');
            }
            
            // Clear previous content
            recommendationContainer.innerHTML = '';
            
            // Add new content based on the selected problem
            const data = recommendationData[problemType];
            if (data) {
                // Create title
                const titleElement = document.createElement('div');
                titleElement.className = 'recommendation-title';
                titleElement.textContent = data.title;
                recommendationContainer.appendChild(titleElement);
                
                // Create goal
                const goalElement = document.createElement('div');
                goalElement.className = 'recommendation-goal';
                goalElement.textContent = data.goal;
                recommendationContainer.appendChild(goalElement);
                
                // Create sections
                data.sections.forEach(section => {
                    // Create section title
                    const sectionTitleElement = document.createElement('div');
                    sectionTitleElement.className = 'recommendation-section-title';
                    sectionTitleElement.textContent = section.title;
                    recommendationContainer.appendChild(sectionTitleElement);
                    
                    // Create list
                    const listElement = document.createElement('ul');
                    listElement.className = 'recommendation-list';
                    
                    // Add list items
                    section.items.forEach(item => {
                        const itemElement = document.createElement('li');
                        itemElement.textContent = item;
                        listElement.appendChild(itemElement);
                    });
                    
                    recommendationContainer.appendChild(listElement);
                });
                
                // Show the recommendation container with animation
                setTimeout(() => {
                    recommendationContainer.classList.add('show');
                }, 10);
            }
        }
        
        // Initialize dashboard
        async function initDashboard() {
            try {
                // Fetch data with cache-busting
                const response = await fetch('./data.json');
                if (!response.ok) {
                    throw new Error('Failed to fetch data');
                }
                
                dashboardData = await response.json();
                
                // Set header
                document.getElementById('dashboard-title').textContent = 'Supergoop! Customer Review Dashboard';
                document.getElementById('last-updated').textContent = `Last updated: ${new Date(dashboardData.meta?.generated_at_utc).toLocaleString()}`;
                
                // Populate filters
                populateFilters();
                
                // Set up event listeners
                setupEventListeners();
                
                // Initial update
                updateDashboard();
                
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                document.getElementById('dashboard-title').textContent = 'Error Loading Dashboard';
                document.getElementById('last-updated').textContent = 'Please check your connection and try again.';
            }
        }
        
        // Populate filter dropdowns
        function populateFilters() {
            // Brand filter
            const brandFilter = document.getElementById('brand-filter');
            brandFilter.innerHTML = '';
            
            const brands = dashboardData.dims?.brands || [];
            const targetBrand = brands.find(b => b.role === 'target');
            
            brands.forEach(brand => {
                const option = document.createElement('option');
                option.value = brand.brand_id;
                option.textContent = brand.brand_name;
                if (targetBrand && brand.brand_id === targetBrand.brand_id) {
                    option.selected = true;
                }
                brandFilter.appendChild(option);
            });
            
            // Secondary Category filter
            updateCategoryFilter();
        }
        
        // Update category filter based on selected brand
        function updateCategoryFilter() {
            const brandId = document.getElementById('brand-filter').value;
            const categoryFilter = document.getElementById('category-filter');
            categoryFilter.innerHTML = '';
            
            if (!brandId) return;
            
            // Get all unique secondary categories for this brand
            const slices = dashboardData.cubes?.brand_secondary_category_slices || [];
            const brandSlices = slices.filter(s => s.brand_id === brandId);
            const uniqueCategories = [...new Set(brandSlices.map(s => s.secondary_category_id))];
            
            // Add "__ALL__" option if available
            if (uniqueCategories.includes("__ALL__")) {
                const allOption = document.createElement('option');
                allOption.value = "__ALL__";
                allOption.textContent = "All Categories";
                allOption.selected = true;
                categoryFilter.appendChild(allOption);
            }
            
            // Add other categories
            const secondaryCategories = dashboardData.dims?.secondary_categories || {};
            uniqueCategories
                .filter(id => id !== "__ALL__")
                .forEach(id => {
                    const option = document.createElement('option');
                    option.value = id;
                    option.textContent = secondaryCategories[id] || id;
                    categoryFilter.appendChild(option);
                });
        }
        
        // Set up event listeners
        function setupEventListeners() {
            document.getElementById('brand-filter').addEventListener('change', () => {
                updateCategoryFilter();
                updateDashboard();
            });
            
            document.getElementById('category-filter').addEventListener('change', updateDashboard);
        }
        
        // Update dashboard based on current filter values
        function updateDashboard() {
            const brandId = document.getElementById('brand-filter').value;
            const categoryId = document.getElementById('category-filter').value;
            
            if (!brandId) return;
            
            const slice = getSlice(brandId, categoryId);
            
            // Update KPI cards
            updateKpiCards(slice);
            
            // Update product lists
            updateProductLists(slice);
            
            // Update charts
            updateRatingChart(slice);
            updatePositiveDriversChart(slice);
            updateNegativeDriversChart(slice);
            updateKeywordsCharts(slice);
            updateBenchmarkChart(brandId);
        }
        
        // Update KPI cards
        function updateKpiCards(slice) {
            if (!slice) {
                document.getElementById('weighted-rating').textContent = '-';
                document.getElementById('pwrs-share').textContent = '-';
                document.getElementById('total-reviews').textContent = '-';
                document.getElementById('positive-share').textContent = '-';
                document.getElementById('negative-share').textContent = '-';
                return;
            }
            
            document.getElementById('weighted-rating').textContent = 
                slice.kpis?.weighted_rating_current ? slice.kpis.weighted_rating_current.toFixed(2) : '-';
            
            document.getElementById('pwrs-share').textContent = 
                slice.kpis?.pwrs_share_current !== undefined ? percent(slice.kpis.pwrs_share_current) : '-';
            
            document.getElementById('total-reviews').textContent = 
                slice.review_volume?.total_reviews ? number(slice.review_volume.total_reviews) : '-';
            
            document.getElementById('positive-share').textContent = 
                slice.review_volume?.sentiment_mix?.positive?.share !== undefined ? 
                percent(slice.review_volume.sentiment_mix.positive.share) : '-';
            
            document.getElementById('negative-share').textContent = 
                slice.review_volume?.sentiment_mix?.negative?.share !== undefined ? 
                percent(slice.review_volume.sentiment_mix.negative.share) : '-';
        }
        
        // Update product lists
        function updateProductLists(slice) {
            // Update highest rated products
            const highestRatedContainer = document.getElementById('highest-rated-products');
            highestRatedContainer.innerHTML = '';
            
            // Update lowest rated products
            const lowestRatedContainer = document.getElementById('lowest-rated-products');
            lowestRatedContainer.innerHTML = '';
            
            if (!slice || !slice.products) {
                highestRatedContainer.innerHTML = '<div class="no-data">No product data available</div>';
                lowestRatedContainer.innerHTML = '<div class="no-data">No product data available</div>';
                return;
            }
            
            // Sort products by rating
            const products = slice.products || [];
            const sortedByRating = [...products].sort((a, b) => b.rating - a.rating);
            
            // Get top 5 highest rated
            const highestRated = sortedByRating.slice(0, 5);
            
            // Get top 5 lowest rated
            const lowestRated = sortedByRating.slice(-5).reverse();
            
            // Create product elements for highest rated
            if (highestRated.length === 0) {
                highestRatedContainer.innerHTML = '<div class="no-data">No product data available</div>';
            } else {
                highestRated.forEach(product => {
                    const productItem = document.createElement('div');
                    productItem.className = 'product-item';
                    
                    const productName = document.createElement('div');
                    productName.className = 'product-name';
                    productName.textContent = product.name || 'Unknown Product';
                    
                    const productRating = document.createElement('div');
                    productRating.className = 'product-rating';
                    
                    const ratingStars = document.createElement('span');
                    ratingStars.className = 'rating-stars';
                    ratingStars.textContent = '★'.repeat(Math.round(product.rating || 0)) + '☆'.repeat(5 - Math.round(product.rating || 0));
                    
                    const ratingValue = document.createElement('span');
                    ratingValue.className = 'rating-value';
                    ratingValue.textContent = (product.rating || 0).toFixed(1);
                    
                    const ratingCount = document.createElement('span');
                    ratingCount.className = 'rating-count';
                    ratingCount.textContent = `(${number(product.review_count || 0)})`;
                    
                    productRating.appendChild(ratingStars);
                    productRating.appendChild(ratingValue);
                    productRating.appendChild(ratingCount);
                    
                    productItem.appendChild(productName);
                    productItem.appendChild(productRating);
                    
                    highestRatedContainer.appendChild(productItem);
                });
            }
            
            // Create product elements for lowest rated
            if (lowestRated.length === 0) {
                lowestRatedContainer.innerHTML = '<div class="no-data">No product data available</div>';
            } else {
                lowestRated.forEach(product => {
                    const productItem = document.createElement('div');
                    productItem.className = 'product-item';
                    
                    const productName = document.createElement('div');
                    productName.className = 'product-name';
                    productName.textContent = product.name || 'Unknown Product';
                    
                    const productRating = document.createElement('div');
                    productRating.className = 'product-rating';
                    
                    const ratingStars = document.createElement('span');
                    ratingStars.className = 'rating-stars';
                    ratingStars.textContent = '★'.repeat(Math.round(product.rating || 0)) + '☆'.repeat(5 - Math.round(product.rating || 0));
                    
                    const ratingValue = document.createElement('span');
                    ratingValue.className = 'rating-value';
                    ratingValue.textContent = (product.rating || 0).toFixed(1);
                    
                    const ratingCount = document.createElement('span');
                    ratingCount.className = 'rating-count';
                    ratingCount.textContent = `(${number(product.review_count || 0)})`;
                    
                    productRating.appendChild(ratingStars);
                    productRating.appendChild(ratingValue);
                    productRating.appendChild(ratingCount);
                    
                    productItem.appendChild(productName);
                    productItem.appendChild(productRating);
                    
                    lowestRatedContainer.appendChild(productItem);
                });
            }
        }
        
        // Update rating chart
        function updateRatingChart(slice) {
            const ctx = document.getElementById('rating-chart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.rating) {
                charts.rating.destroy();
            }
            
            if (!slice || !slice.review_volume?.rating_distribution) {
                // Show no data message
                charts.rating = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['1', '2', '3', '4', '5'],
                        datasets: [{
                            data: [0, 0, 0, 0, 0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                });
                return;
            }
            
            const ratingData = slice.review_volume.rating_distribution;
            const labels = ['1', '2', '3', '4', '5'];
            const data = labels.map(rating => ratingData[rating]?.share || 0);
            const counts = labels.map(rating => ratingData[rating]?.count || 0);
            
            charts.rating = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Share',
                        data: data,
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.7)',
                            'rgba(255, 159, 64, 0.7)',
                            'rgba(255, 205, 86, 0.7)',
                            'rgba(75, 192, 192, 0.7)',
                            'rgba(54, 162, 235, 0.7)'
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return percent(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    return `Share: ${percent(data[index])}, Count: ${number(counts[index])}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update positive drivers chart
        function updatePositiveDriversChart(slice) {
            const ctx = document.getElementById('positive-drivers-chart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.positiveDrivers) {
                charts.positiveDrivers.destroy();
            }
            
            if (!slice || !slice.drivers?.positive || slice.drivers.positive.length === 0) {
                // Show no data message
                charts.positiveDrivers = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No data'],
                        datasets: [{
                            data: [0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                });
                return;
            }
            
            const drivers = slice.drivers.positive.slice(0, 9);
            const labels = drivers.map(d => d.driver);
            const data = drivers.map(d => d.share);
            const counts = drivers.map(d => d.count);
            
            charts.positiveDrivers = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Share',
                        data: data,
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return percent(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    return `Share: ${percent(data[index])}, Count: ${number(counts[index])}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update negative drivers chart
        function updateNegativeDriversChart(slice) {
            const ctx = document.getElementById('negative-drivers-chart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.negativeDrivers) {
                charts.negativeDrivers.destroy();
            }
            
            if (!slice || !slice.drivers?.negative || slice.drivers.negative.length === 0) {
                // Show no data message
                charts.negativeDrivers = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No data'],
                        datasets: [{
                            data: [0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                });
                return;
            }
            
            const drivers = slice.drivers.negative.slice(0, 9);
            const labels = drivers.map(d => d.driver);
            const data = drivers.map(d => d.share);
            const counts = drivers.map(d => d.count);
            
            charts.negativeDrivers = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Share',
                        data: data,
                        backgroundColor: 'rgba(255, 99, 132, 0.7)',
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return percent(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    return `Share: ${percent(data[index])}, Count: ${number(counts[index])}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update keywords charts
        function updateKeywordsCharts(slice) {
            const positiveCtx = document.getElementById('positive-keywords-chart').getContext('2d');
            const negativeCtx = document.getElementById('negative-keywords-chart').getContext('2d');
            
            // Destroy existing charts if they exist
            if (charts.positiveKeywords) {
                charts.positiveKeywords.destroy();
            }
            if (charts.negativeKeywords) {
                charts.negativeKeywords.destroy();
            }
            
            if (!slice) {
                // Show no data message
                charts.positiveKeywords = new Chart(positiveCtx, {
                    type: 'bar',
                    data: {
                        labels: ['No data'],
                        datasets: [{
                            data: [0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                });
                
                charts.negativeKeywords = new Chart(negativeCtx, {
                    type: 'bar',
                    data: {
                        labels: ['No data'],
                        datasets: [{
                            data: [0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)'
                        }]
                    },
                    options: {
                        indexAxis: 'y',
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        }
                    }
                });
                return;
            }
            
            // Always use "All Drivers" view since the filter is removed
            const positiveKeywords = slice.keywords?.top_positive || [];
            const negativeKeywords = slice.keywords?.top_negative || [];
            
            // Get all negative keywords to exclude from positive
            const negativeKeywordNames = new Set(negativeKeywords.map(k => k.keyword));
            
            // Filter positive keywords to exclude those already in negative
            const filteredPositiveKeywords = positiveKeywords.filter(k => !negativeKeywordNames.has(k.keyword));
            
            // Sort and get top 10
            const sortedPositiveKeywords = filteredPositiveKeywords
                .sort((a, b) => b.mention_count - a.mention_count)
                .slice(0, 10);
                
            const sortedNegativeKeywords = negativeKeywords
                .sort((a, b) => b.mention_count - a.mention_count)
                .slice(0, 10);
            
            // Positive keywords chart
            const posLabels = sortedPositiveKeywords.map(k => k.keyword);
            const posData = sortedPositiveKeywords.map(k => k.mention_count);
            
            charts.positiveKeywords = new Chart(positiveCtx, {
                type: 'bar',
                data: {
                    labels: posLabels,
                    datasets: [{
                        label: 'Mentions',
                        data: posData,
                        backgroundColor: 'rgba(75, 192, 192, 0.7)',
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const keyword = sortedPositiveKeywords[index];
                                    return [
                                        `Keyword: ${keyword.keyword}`,
                                        `Driver: ${keyword.driver}`,
                                        `Total Mentions: ${number(keyword.mention_count)}`,
                                        `Positive: ${number(keyword.pos_mentions)} (${percent(keyword.pos_share)})`,
                                        `Neutral: ${number(keyword.neu_mentions)} (${percent(keyword.neu_share)})`,
                                        `Negative: ${number(keyword.neg_mentions)} (${percent(keyword.neg_share)})`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
            
            // Negative keywords chart
            const negLabels = sortedNegativeKeywords.map(k => k.keyword);
            const negData = sortedNegativeKeywords.map(k => k.mention_count);
            
            charts.negativeKeywords = new Chart(negativeCtx, {
                type: 'bar',
                data: {
                    labels: negLabels,
                    datasets: [{
                        label: 'Mentions',
                        data: negData,
                        backgroundColor: 'rgba(255, 99, 132, 0.7)',
                        borderWidth: 0
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const keyword = sortedNegativeKeywords[index];
                                    return [
                                        `Keyword: ${keyword.keyword}`,
                                        `Driver: ${keyword.driver}`,
                                        `Total Mentions: ${number(keyword.mention_count)}`,
                                        `Positive: ${number(keyword.pos_mentions)} (${percent(keyword.pos_share)})`,
                                        `Neutral: ${number(keyword.neu_mentions)} (${percent(keyword.neu_share)})`,
                                        `Negative: ${number(keyword.neg_mentions)} (${percent(keyword.neg_share)})`
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update benchmark chart
        function updateBenchmarkChart(selectedBrandId) {
            const benchmarkContainer = document.getElementById('benchmark-container');
            const ctx = document.getElementById('benchmark-chart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (charts.benchmark) {
                charts.benchmark.destroy();
            }
            
            if (!dashboardData.market?.benchmark_brands || dashboardData.market.benchmark_brands.length === 0) {
                benchmarkContainer.style.display = 'none';
                return;
            }
            
            benchmarkContainer.style.display = 'block';
            
            const benchmarkBrands = dashboardData.market.benchmark_brands;
            const labels = benchmarkBrands.map(b => b.brand_name);
            const data = benchmarkBrands.map(b => b.pwrs_share);
            const backgroundColors = benchmarkBrands.map(b => {
                return b.brand_id === selectedBrandId ? 'rgba(233, 30, 99, 0.7)' : 'rgba(200, 200, 200, 0.5)';
            });
            
            charts.benchmark = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'PWRS Share',
                        data: data,
                        backgroundColor: backgroundColors,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return percent(value);
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `PWRS Share: ${percent(context.raw)}`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Initialize the dashboard when the page loads
        document.addEventListener('DOMContentLoaded', initDashboard);
    </script>
</body>
</html>
